"""
Codebase Genius - Implementation Details
"""

# RepoMapper implementation
impl RepoMapper.clone_and_scan {
    print(f"[RepoMapper] Cloning {self.repo.url}...");
    
    repo_name = self.repo.url.rstrip("/").split("/")[-1].replace(".git", "");
    self.repo.name = repo_name;
    
    local_path = f"./tmp_repos/{repo_name}";
    self.repo.local_path = local_path;
    
    if not Path(local_path).exists() {
        # Get GitHub token from environment
        github_token = os.getenv("GITHUB_TOKEN", "");
        
        # Modify URL to include token if available
        clone_url = self.repo.url;
        if github_token and "github.com" in clone_url {
            # Convert https://github.com/user/repo to https://token@github.com/user/repo
            clone_url = clone_url.replace("https://", f"https://{github_token}@");
        }
        
        try {
            git.Repo.clone_from(clone_url, local_path, depth=1);
            print(f"[RepoMapper] Cloned to {local_path}");
        } except Exception as e {
            print(f"[RepoMapper] Clone failed: {e}");
            # Try without token
            git.Repo.clone_from(self.repo.url, local_path, depth=1);
            print(f"[RepoMapper] Cloned to {local_path} (without token)");
        }
    } else {
        print(f"[RepoMapper] Repository already exists");
    }
    
    p = Path(local_path);
    ignore_dirs = {".git", "__pycache__", "node_modules", "venv", ".venv", "dist", "build"};
    files = [];
    
    for file in p.rglob("*") {
        if file.is_file() and file.suffix in [".py", ".jac"] {
            in_ignore = any(part in ignore_dirs for part in file.parts);
            
            if not in_ignore {
                rel_path = str(file.relative_to(p));
                files.append(rel_path);
            }
        }
    }
    
    self.repo.files = files;
    print(f"[RepoMapper] Found {len(files)} code files");
    
    readme_processor = ReadmeProcessor();
    self.repo.readme_summary = readme_processor.process(local_path);
    
    # Generate and store the file tree
    tree_gen = FileTreeGenerator();
    file_tree = tree_gen.generate(local_path, ignore_dirs);
    self.repo.file_tree = file_tree;
    print(f"[RepoMapper] Generated file tree");

    self.status = "mapped";
}

# CodeAnalyzer implementation
impl CodeAnalyzer.analyze_file {
    print(f"[CodeAnalyzer] Analyzing {self.file_info.path}...");
    
    full_path = Path(repo_path) / self.file_info.path;
    if not full_path.exists() {
        return;
    }
    
    content = full_path.read_text();
    
    parser = FileParser();
    symbols_data = parser.extract_symbols(content, self.file_info.path);
    
    # Convert dict symbols to Symbol objects
    for sym_dict in symbols_data {
        sym_obj = Symbol(
            name=sym_dict.get("name", ""),
            type=sym_dict.get("type", ""),
            file=sym_dict.get("file", ""),
            line=sym_dict.get("line", 0)
        );
        self.file_info.symbols.append(sym_obj);
    }
    
    self.analyzed = True;
    print(f"[CodeAnalyzer] Found {len(self.file_info.symbols)} symbols");
}

# DocGenie implementation
impl DocGenie.generate_markdown {
    print(f"[DocGenie] Generating documentation for {repo.name}...");
    
    try {
        md = "# " + repo.name + " Documentation\n\n";
        md = md + "**Generated by Codebase Genius üß†**\n\n";
        md = md + "---\n\n";
        
        md = md + "## Overview\n\n";
        if repo.readme_summary {
            # Use the new AI-powered ability to generate a better overview
            try {
                key_symbols = [sym.name for sym in all_symbols[:15]];
                ai_overview = self.generate_ai_overview(repo.readme_summary, key_symbols);
                md = md + ai_overview + "\n\n";
            } except Exception as e {
                print(f"[DocGenie] ‚ö†Ô∏è AI overview failed: {e}. Falling back to basic summary.");
                md = md + repo.readme_summary + "\n\n";
            }
        } else {
            md = md + "Automated documentation for this repository.\n\n";
        }
        
        md = md + "## Repository Structure\n\n";
        md = md + "**Total Files:** " + str(len(repo.files)) + "\n\n";
        
        # Add the generated file tree to the documentation
        md = md + "```text\n";
        md = md + repo.file_tree + "\n";
        md = md + "```\n\n";
        
        md = md + "## API Reference\n\n";
        
        file_symbols = {};
        for sym in all_symbols {
            # Handle both dict and object access
            sym_file = sym.get("file") if isinstance(sym, dict) else sym.file;
            
            if sym_file not in file_symbols {
                file_symbols[sym_file] = [];
            }
            file_symbols[sym_file].append(sym);
        }
        
        for file_path in sorted(file_symbols.keys()) {
            md = md + "### `" + file_path + "`\n\n";
            syms = file_symbols[file_path];
            
            for sym in syms {
                # Handle both dict and object access
                sym_name = sym.get("name") if isinstance(sym, dict) else sym.name;
                sym_type = sym.get("type") if isinstance(sym, dict) else sym.type;
                sym_line = sym.get("line") if isinstance(sym, dict) else sym.line;
                
                md = md + "- **" + sym_name + "** (" + sym_type + ") - Line " + str(sym_line) + "\n";
            }
            md = md + "\n";
        }
        
        md = md + "## Architecture Diagram\n\n";
        # This is a great place to use `by llm` in the future to generate
        # a more intelligent diagram based on symbol relationships.
        # For example: `diagram_code by llm(f"Generate a Mermaid sequence diagram for: {all_symbols}");`

        md = md + "```mermaid\n";
        md = md + "graph TD\n";
        
        # Create a set of all defined symbols for filtering calls
        defined_symbols = {s.get("name") if isinstance(s, dict) else s.name for s in all_symbols};

        for sym in all_symbols {
            sym_type = sym.get("type") if isinstance(sym, dict) else sym.type;
            sym_name = sym.get("name") if isinstance(sym, dict) else sym.name;
            
            # Add nodes for major components
            if sym_type in ["class", "node", "walker", "function"] {
                md = md + "    " + sym_name + "[" + sym_name + "]\n";
            }

            # Add edges for relationships (calls and inheritance)
            # This check is robust for both dicts and objects
            is_dict = isinstance(sym, dict);
            
            if sym_type == "function" and (is_dict and "calls" in sym) {
                if sym.get("calls") {
                    for call in sym.get("calls") {
                        if call in defined_symbols {
                            md = md + "    " + sym_name + " --> " + call + "\n";
                        }
                    }
                }
            }
            
            if sym_type == "class" and (is_dict and "inherits" in sym) {
                if sym.get("inherits") {
                    for parent in sym.get("inherits") {
                        md = md + "    " + parent + " --|> " + sym_name + "\n";
                    }
                }
            }
        }
        
        md = md + "```\n\n";
        
        md = md + "## Installation\n\n";
        md = md + "```bash\n";
        md = md + "git clone " + repo.url + "\n";
        md = md + "cd " + repo.name + "\n";
        md = md + "pip install -r requirements.txt\n";
        md = md + "```\n\n";
        
        # Create output directory and save file
        output_dir = Path("./outputs") / repo.name;
        print(f"[DocGenie] Creating output directory: {output_dir}");
        output_dir.mkdir(parents=True, exist_ok=True);
        
        doc_path = output_dir / "documentation.md";
        print(f"[DocGenie] Writing documentation to: {doc_path}");
        doc_path.write_text(md, encoding='utf-8');
        
        self.output.repo_name = repo.name;
        self.output.markdown = md;
        self.output.output_path = str(doc_path);
        self.output.status = "success";
        
        print(f"[DocGenie] Documentation saved successfully to {doc_path}");
        
    } except Exception as e {
        print(f"[DocGenie] ‚ùå Error generating documentation: {e}");
        import traceback;
        traceback.print_exc();
        self.output.repo_name = repo.name;
        self.output.markdown = "";
        self.output.output_path = "";
        self.output.status = "failed";
    }
}

# CodeGenius walker implementation
impl CodeGenius.orchestrate {
    print("="*60);
    print("üß† Codebase Genius - Multi-Agent Documentation System");
    print("="*60);
    print(f"Repository: {self.repo_url}");
    print("");
    
    print("\n[Stage 1/3] Repository Mapping");
    print("-" * 40);
    repo_mapper = RepoMapper();
    repo_mapper.repo.url = self.repo_url;
    repo_mapper.clone_and_scan();
    self.repo_info = repo_mapper.repo;
    
    print("\n[Stage 2/3] Code Analysis");
    print("-" * 40);
    for file_path in self.repo_info.files {
        analyzer = CodeAnalyzer();
        analyzer.file_info.path = file_path;
        analyzer.file_info.language = "python" if file_path.endswith(".py") else "jac";
        analyzer.analyze_file(self.repo_info.local_path);
        
        for sym in analyzer.file_info.symbols {
            self.all_symbols.append(sym);
        }
    }
    
    print(f"\n[Pipeline] Total symbols found: {len(self.all_symbols)}");
    
    print("\n[Stage 3/3] Documentation Generation");
    print("-" * 40);
    doc_gen = DocGenie();
    doc_gen.generate_markdown(self.repo_info, self.all_symbols);
    self.final_output = doc_gen.output;
    
    print("\n" + "="*60);
    print("‚úÖ Documentation Generation Complete!");
    print(f"üìÑ Output: {self.final_output.output_path}");
    print("="*60);
}

# API walker implementation
impl generate_docs.execute {
    print(f"[API] Generating docs for {self.repo_url}");
    
    pipeline = CodeGenius(repo_url=self.repo_url) spawn root;
    
    report {
        "status": pipeline.final_output.status,
        "repo_name": pipeline.final_output.repo_name,
        "output_path": pipeline.final_output.output_path,
        "symbols_count": len(pipeline.all_symbols)
    };
}